# architect_http_api/gf/engine.py
# =========================================================================
# GF ENGINE: Runtime Interface for Grammatical Framework
#
# This class wraps the low-level 'pgf' library. It handles:
# 1. Loading the compiled 'Wiki.pgf' binary.
# 2. Linearizing Abstract Syntax Trees (ASTs) into text for specific languages.
# 3. Mapping ISO language codes (e.g., 'eng') to Concrete Grammars ('WikiEng').
# =========================================================================

import os
import pgf
from typing import Optional, List, Dict, Any

class GFEngineError(Exception):
    """Base exception for GF-related runtime errors."""
    pass

class GFEngine:
    """
    The main interface for interacting with the GF Runtime.
    Ideally instantiated once and shared across the application.
    """
    
    _instance: Optional['GFEngine'] = None
    
    def __init__(self, pgf_path: Optional[str] = None):
        """
        Initialize the engine by loading the PGF file.
        
        Args:
            pgf_path: Path to 'Wiki.pgf'. If None, attempts to auto-locate it
                      relative to this file.
        """
        if pgf_path is None:
            # Default location: ../../gf/Wiki.pgf relative to this file
            current_dir = os.path.dirname(os.path.abspath(__file__))
            pgf_path = os.path.abspath(os.path.join(current_dir, "../../gf/Wiki.pgf"))

        self.pgf_path = pgf_path
        self._grammar: Optional[pgf.PGF] = None
        
        self._load_grammar()

    def _load_grammar(self):
        """Internal method to safely load the PGF file."""
        if not os.path.exists(self.pgf_path):
            raise GFEngineError(f"PGF file not found at: {self.pgf_path}. Did you run the build script?")
        
        try:
            self._grammar = pgf.readPGF(self.pgf_path)
        except Exception as e:
            raise GFEngineError(f"Failed to load PGF file: {e}")

    @classmethod
    def get_instance(cls, pgf_path: Optional[str] = None) -> 'GFEngine':
        """
        Singleton accessor. Returns the shared instance of the engine.
        """
        if cls._instance is None:
            cls._instance = cls(pgf_path)
        return cls._instance

    def has_language(self, lang_code: str) -> bool:
        """Checks if a language is supported by the loaded grammar."""
        concrete_name = self._get_concrete_name(lang_code)
        return concrete_name in self._grammar.languages

    def _get_concrete_name(self, lang_code: str) -> str:
        """
        Maps a generic code (e.g., 'eng') to the specific concrete syntax name 
        generated by the build script (e.g., 'WikiEng').
        """
        # Our build script names concretes as "Wiki" + Capitalized Code
        return f"Wiki{lang_code.capitalize()}"

    def linearize(self, ast_string: str, lang_code: str) -> str:
        """
        Converts a GF Abstract Syntax Tree (string representation) into natural language.
        
        Args:
            ast_string: The AST, e.g., "mkFact (apple_Entity) (red_Property)"
            lang_code: The ISO 639-3 code, e.g., "eng", "fra", "zho"
            
        Returns:
            The generated string (e.g., "The apple is red").
        """
        if not self._grammar:
            raise GFEngineError("Grammar not loaded.")

        concrete_name = self._get_concrete_name(lang_code)
        
        if concrete_name not in self._grammar.languages:
            raise GFEngineError(f"Language '{lang_code}' (Concrete: {concrete_name}) not found in PGF.")
        
        concrete = self._grammar.languages[concrete_name]
        
        try:
            # Parse the AST string into a PGF expression object
            expr = pgf.readExpr(ast_string)
            
            # Linearize the expression
            # concrete.linearize returns a generator of strings; we take the first/best one.
            return concrete.linearize(expr)
            
        except pgf.HelperError as e:
            # This usually means the AST string has syntax errors
            raise GFEngineError(f"Invalid AST format: {e}")
        except Exception as e:
            raise GFEngineError(f"Linearization failed for '{ast_string}': {e}")

    def get_all_languages(self) -> List[str]:
        """Returns a list of all loaded concrete syntax names."""
        if not self._grammar:
            return []
        return list(self._grammar.languages.keys())

    def get_lexicon_function_names(self) -> List[str]:
        """
        Returns a list of all abstract functions defined in the grammar.
        Used by the Lexicon Syncer to discover available vocabulary.
        """
        if not self._grammar:
            return []
        # .functions returns a dict-like object of all abstract functions
        return list(self._grammar.functions.keys())