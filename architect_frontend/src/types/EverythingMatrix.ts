// architect_frontend/src/types/EverythingMatrix.ts

/**
 * The Root Object for the Everything Matrix (backend-generated)
 * Matches data/indices/everything_matrix.json generated by tools/everything_matrix/build_index.py
 *
 * Canonical key rule (v2+):
 * - matrix.languages is keyed by ISO-639-1 (iso2) lowercase (e.g., "en", "fr").
 * - meta.iso is the same iso2 key for the row.
 */
export interface EverythingMatrix {
  timestamp: number; // Unix timestamp (float/int from Python time.time())
  timestamp_iso?: string; // Optional ISO timestamp (UTC) if backend emits it
  scoring_version?: string; // optional; present in newer artifacts
  stats: {
    total_languages: number;
    production_ready: number; // maturity >= 8 AND strategy = HIGH_ROAD
    safe_mode: number; // strategy = SAFE_MODE
    skipped: number; // strategy = SKIP
    high_road?: number; // optional; present in newer artifacts
    runnable?: number; // optional; present in newer artifacts
  };
  /**
   * Keyed by iso2 (lowercase), e.g.:
   *   "en": { ... },
   *   "fr": { ... }
   */
  languages: Record<string, LanguageEntry>;
}

/**
 * Represents a single Language in the Matrix
 */
export interface LanguageEntry {
  meta: LanguageMeta;
  zones: LanguageZones;
  verdict: LanguageVerdict;
}

/**
 * Metadata about the language identity
 *
 * Canonical:
 * - `iso` is ISO-639-1 (iso2), lowercase, and matches the matrix.languages key.
 * - `name` is injected by backend from config/iso_to_wiki.json (if present),
 *   with fallback to iso uppercased.
 */
export interface LanguageMeta {
  iso: string; // iso2, e.g. "en", "fr"
  name: string; // Display name (backend-injected; fallback is ISO uppercased)
  tier: number; // 1 (RGL) or 3 (Factory)
  origin: string; // "rgl" | "factory" | "lexicon" (backend may extend)
  folder: string; // e.g. "english" or "generated"
}

/**
 * The 4 Health Zones containing the 14 Metrics
 */
export interface LanguageZones {
  A_RGL: ZoneA_RGL;
  B_LEX: ZoneB_Lexicon;
  C_APP: ZoneC_App;
  D_QA: ZoneD_Quality;
}

// --- ZONE DEFINITIONS (All scores 0.0 - 10.0) ---

/**
 * Zone A: Logic & Grammar Engine (RGL)
 */
export interface ZoneA_RGL {
  CAT: number; // Categories (CatX.gf)
  NOUN: number; // Morphology (NounX.gf)
  PARA: number; // Paradigms (ParadigmsX.gf)
  GRAM: number; // Grammar Core (GrammarX.gf)
  SYN: number; // Syntax API (SyntaxX.gf)
}

/**
 * Zone B: Data & Lexicon
 */
export interface ZoneB_Lexicon {
  SEED: number; // Core Vocabulary (core.json)
  CONC: number; // Domain Concepts (people.json and/or other shards)
  WIDE: number; // Bulk Imports (wide.json)
  SEM: number; // Semantic Alignment (Wikidata QIDs)
}

/**
 * Zone C: Application & Use Case
 */
export interface ZoneC_App {
  PROF: number; // Bio-Ready (profiles + flags)
  ASST: number; // Chat-Ready (dialog artifacts)
  ROUT: number; // Topology Routing Configured
}

/**
 * Zone D: Quality Assurance
 */
export interface ZoneD_Quality {
  BIN: number; // Present in compiled .pgf binary
  TEST: number; // Regression Test Pass Rate
}

/**
 * High-level status and Orchestrator decision
 */
export interface LanguageVerdict {
  maturity_score: number; // Weighted Average (0.0 - 10.0)
  build_strategy: "HIGH_ROAD" | "SAFE_MODE" | "SKIP" | (string & {});
  runnable: boolean; // If false, excluded from Runtime to prevent crash

  // Optional newer fields (present in recent artifacts)
  scoring_version?: string;
  zone_weights?: Partial<Record<ZoneKey, number>>;
  zone_averages?: Partial<Record<ZoneKey, number>>;

  /**
   * Optional UI helpers (backward-compatible).
   * If backend doesnâ€™t emit them, frontend can compute them.
   */
  completion?: CompletionInfo;
}

/**
 * Optional precomputed completion summary for UI.
 * If not provided by backend, the frontend can derive it from zones + verdict.
 */
export interface CompletionInfo {
  /**
   * Normalized 0..1 completion ratio for the whole language.
   * Example: maturity_score / 10.
   */
  ratio: number;

  /**
   * A bucket suitable for color coding.
   * Frontend can map these to classes/colors.
   */
  level: CompletionLevel;

  /**
   * Optional per-zone ratios (0..1) for richer columns/heatmap.
   */
  zones?: Partial<Record<ZoneKey, number>>;
}

export type CompletionLevel =
  | "none" // 0
  | "low" // >0..0.3
  | "medium" // 0.3..0.7
  | "high" // 0.7..0.9
  | "complete"; // >=0.9

export type ZoneKey = "A_RGL" | "B_LEX" | "C_APP" | "D_QA";
