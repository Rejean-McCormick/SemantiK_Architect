
# ðŸ§© RGL Integration & Dynamic Discovery Strategy

**Abstract Wiki Architect v2.0 - Internal Reference**

## 1. The "Naming Mismatch" Problem

A critical challenge in integrating the **GF Resource Grammar Library (RGL)** is the discrepancy between our system's ISO standards and RGL's internal naming conventions.

| Standard | Identifier | Example (French) | Example (German) | Example (Chinese) |
| :--- | :--- | :--- | :--- | :--- |
| **Abstract Wiki (Ours)** | ISO 639-3 | `fra` | `deu` | `zho` |
| **GF RGL (Internal)** | Legacy 3-Letter | `Fre` | `Ger` | `Chi` |
| **File System** | Folder Name | `french` | `german` | `chinese` |

**The Conflict:**
The build system cannot simply capitalize the ISO code.
* `WikiFra` (Expected) â‰  `SyntaxFre` (Actual).
* `WikiDeu` (Expected) â‰  `SyntaxGer` (Actual).

Previous attempts to solve this involved hardcoded dictionaries or parsing `languages.csv`. However, investigation revealed that **`languages.csv` does not contain ISO 639-3 codes**, making it insufficient as a translation layer.

---

## 2. The Solution: "Matrix + Scanner" Algorithm

To solve this without maintaining a fragile hardcoded list, the **Build Orchestrator** (`gf/build_orchestrator.py`) implements a **Dynamic Discovery Algorithm** that trusts the file system as the ultimate source of truth.

### The 4-Step Resolution Process

When the builder processes a language (e.g., `fra`):

#### Step 1: Matrix Lookup (ISO â†’ Folder)
It queries the **Everything Matrix** (`data/indices/everything_matrix.json`), which is generated by the daily system scan. The Matrix provides the physical folder location.
```json
"fra": {
  "meta": { "folder": "french" } // The Matrix knows the path
}

```

#### Step 2: Physical Audit (Folder â†’ Files)

The orchestrator explicitly checks the `gf-rgl/src/french/` directory on disk. It searches for the existence of the core syntax file using a glob pattern:

* **Pattern:** `gf-rgl/src/french/Syntax*.gf`

#### Step 3: Suffix Extraction (File â†’ RGL Code)

The scan returns the actual filename found on disk, e.g., `SyntaxFre.gf`.
The system strips the prefix (`Syntax`) and extension (`.gf`) to extract the **True RGL Suffix**:

* `SyntaxFre.gf` â†’ **`Fre`**

#### Step 4: Connector Generation (The "Empty Connector" Pattern)

The system generates a compatibility bridge (`WikiFre.gf`) that links our abstract grammar to the discovered RGL module.

**Critical Optimization:** The generated body is intentionally **Empty**.

* **Old Way (Fragile):** `lin lex_animal_N = mkNP (mkN "animal");` -> Crashed on Chinese/Turkish due to parameter mismatches.
* **New Way (Robust):** `     ` (Empty Body).
* **Result:** 100% compilation success. Vocabulary is injected dynamically at runtime via the Lexicon JSONs, decoupled from the static binary build.

```haskell
-- Generated: WikiFre.gf
concrete WikiFre of AbstractWiki = WikiI ** open SyntaxFre, ParadigmsFre in {
  -- Empty body guarantees compilation success.
  -- Vocabulary is injected at runtime.
}

```

---

## 3. Directory Structure Constraints

For this discovery to work, the directory layout must strictly follow the **Nested Hybrid** structure.

**Correct Layout:**

```text
/ProjectRoot/
â”œâ”€â”€ abstract-wiki-architect/   <-- [CWD] Current Working Directory
â”‚   â”œâ”€â”€ gf/
â”‚   â”‚   â””â”€â”€ build_orchestrator.py
â”‚   â””â”€â”€ ...
â””â”€â”€ gf-rgl/                    <-- [CRITICAL] Must be a sibling or child
    â””â”€â”€ src/
        â”œâ”€â”€ french/            <-- Matrix "folder"
        â”‚   â””â”€â”€ SyntaxFre.gf   <-- Discovery Target
        â””â”€â”€ ...

```

* **Launch Script Fix:** The `launch.ps1` script explicitly sets the working directory (`$WSL_PATH`) to ensure relative path resolution works regardless of where the script is executed.

---

## 4. Why this is Robust

1. **Zero Maintenance:** If the RGL renames `SyntaxFre.gf` to `SyntaxFra.gf` in a future version, our scanner will automatically detect the new name and generate the correct connector without a code change.
2. **No CSV Dependency:** We do not rely on `languages.csv`, which is prone to schema changes and missing ISO data.
3. **Self-Healing:** If a folder is missing, the scanner fails gracefully, triggers the **Resilient Loop**, logs the error, and continues building the remaining languages instead of crashing the entire pipeline.

```

```