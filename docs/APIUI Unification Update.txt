## SemantiK Architect — Enterprise-Grade API/UI Unification Update

### Summary

This update removes contract drift between the frontend and backend by enforcing:

* One canonical backend entrypoint
* One canonical API base path (`/api/v1`)
* One canonical frontend API client
* A consistent reverse-proxy topology for `/abstract_wiki_architect`
* A stable, versioned language + entity API contract
* Clear separation of public vs admin endpoints and authentication
* A secure, allowlisted **Tools API** for the `/tools` dashboard (no arbitrary execution)

This documentation describes the final target state, the exact files to change, the new API contract, deployment wiring (Docker + Nginx), testing, and rollback.

---

## 1) Current problems this update resolves

### 1.1 Multiple backend “apps” with different behavior

You currently have multiple FastAPI apps and patterns:

* `app/main.py` (router-based, mounts `/api/v1/*`, also disables security)
* `app/adapters/api/main.py` (router-based, used by docker-compose)
* `app/adapters/api.py` (separate app with a different interface)
* `app/adapters/api/routes.py` (older router)

Result: “the backend” depends on how it is started. Frontend cannot reliably target it.

### 1.2 Two frontend API clients with different base URLs and endpoints

* `architect_frontend/src/services/api.ts` uses `NEXT_PUBLIC_API_URL` and calls `/api/v1/languages`
* `architect_frontend/src/lib/api.ts` uses `NEXT_PUBLIC_ARCHITECT_API_BASE_URL` and calls `/languages`, `/entities/`, etc.

Result: UI loads some data from one client and other data from another, with inconsistent configuration and endpoints.

### 1.3 Languages endpoint mismatch

* Frontend expects `Language[]` objects `{code,name,z_id}`
* Backend languages router returns `List[str]` codes and is not mounted
* Management router uses `/api/v1/languages` but is protected by `verify_api_key` and provides POST-only endpoints

Result: language selector fails (404/401) and contract mismatch even if mounted.

### 1.4 Reverse-proxy topology mismatch for Docker

`deploy/nginx.conf` proxies to `127.0.0.1:4000` from inside a container, which is not the frontend service.

Result: unstable/infinite loops/connection failures in containerized deployments.

### 1.5 Tools execution drift + security risk

Historically, “tools” execution tends to drift into:

* multiple ad-hoc endpoints
* arbitrary command execution
* inconsistent output formats
* no argument policy enforcement

Result: a tools dashboard cannot be safely productionized.

This update standardizes tools execution behind:

* strict allowlist registry (tool IDs only)
* repo-root confinement
* flag allowlisting (prevents injection)
* output truncation + timeouts
* consistent response envelope with lifecycle events
* API-key protection

---

## 2) Target architecture (final state)

### 2.1 Canonical API

* Backend serves **only one** HTTP API contract at **`/api/v1`**
* All client-facing endpoints live under `/api/v1/*`
* Public read endpoints are accessible without admin credentials (configurable)
* Admin endpoints require auth (API key or token), enforced per-router or per-endpoint

### 2.2 Canonical frontend API client

* Frontend uses **only** `architect_frontend/src/lib/api.ts` (`architectApi`)
* `architect_frontend/src/services/api.ts` is removed or becomes a thin re-export (no independent base URL)

### 2.3 Deployment paths

* UI base path: `/abstract_wiki_architect` (configured via `next.config.mjs basePath`)
* API path for same-origin calls: `/abstract_wiki_architect/api/v1`
* Nginx routes `/abstract_wiki_architect/api/*` to backend and `/abstract_wiki_architect/*` to frontend

### 2.4 Tools API (GUI-driven operations)

* Tools endpoints live under `/api/v1/tools/*`
* Tools are executed only by allowlisted `tool_id`
* Tools endpoints are **admin-only** (API key required)

---

## 3) Decisions and standards

### 3.1 Language code standard (required decision)

There are two distinct “language code” surfaces in the system:

1. **Public API/UI language identity** (what a user selects in the UI; what `/api/v1/languages` returns).
2. **Internal data/layout + tool arguments** (how lexicon directories are named; how harvesters and build tools target language resources).

**This update standardizes tool-facing language arguments to ISO-639-1 (ISO-2) codes** (e.g., `en`, `fr`) because:

* the harvester pipeline and language mapping are driven by `iso_to_wiki.json` (ISO-2 keys)
* lexicon output paths are organized under `data/lexicon/{iso2}/…`
* tools must accept a compact, stable, filesystem-friendly code

**Public API/UI language standard remains unchanged by this update.**
If the UI remains ISO-639-3 (`eng`, `zul`), treat mapping between ISO-639-3 and ISO-639-1 as an explicit translation layer (not implicit drift). If you later choose to unify them, do it as a separate migration with dual identifiers and a clear canonical field.

---

## 4) File-by-file change list (authoritative)

### 4.1 Backend

**Canonical entrypoint and router mounting**

* `app/adapters/api/main.py`

  * Remains canonical app used by Docker and production
  * Must mount public languages router under `/api/v1/languages` (GET list)
  * Keeps admin “management” endpoints under `/api/v1/languages/*` but protected
  * Must mount tools router under `/api/v1/tools/*` (admin-only)

**Tools router (enterprise-grade)**

* `app/adapters/api/routers/tools.py`

  * Implements the allowlist registry (`TOOL_REGISTRY`)
  * Provides:

    * `GET /api/v1/tools/registry`
    * `POST /api/v1/tools/run`
  * Enforces:

    * repo-root confinement via `FILESYSTEM_REPO_PATH`
    * argument allowlisting per tool
    * output truncation (`ARCHITECT_TOOLS_MAX_OUTPUT_CHARS`)
    * timeouts (`ARCHITECT_TOOLS_DEFAULT_TIMEOUT_SEC`)
    * AI gating (`ARCHITECT_ENABLE_AI_TOOLS`)
  * Returns a stable response envelope (no raw `{detail: ...}`)

**Public languages router contract**

* `app/adapters/api/routers/languages.py`

  * Change from `List[str]` to `List[LanguageOut]` objects to match frontend
  * Provide `GET /api/v1/languages`

**Admin language lifecycle**

* `app/adapters/api/routers/management.py`

  * Keep as admin-only (onboard/build) endpoints
  * Ensure auth is applied only to admin endpoints

**Deprecate duplicate apps (do not run in production)**

* `app/main.py`

  * Remove “force security off”
  * Optionally: import/expose canonical `app` from `app/adapters/api/main.py`
* `app/adapters/api.py` and `app/adapters/api/routes.py`

  * Mark deprecated / remove from runtime paths to prevent accidental execution

### 4.2 Frontend

**Single client**

* `architect_frontend/src/components/LanguageSelector.tsx`

  * Switch to `architectApi.listLanguages()` from `src/lib/api.ts`
  * Remove import of `getLanguages()` from `src/services/api.ts`

**Tools dashboard registry source**

* `architect_frontend/src/app/tools/backendRegistry.ts`

  * Tool IDs must match backend `TOOL_REGISTRY` keys
  * Keep metadata in sync (risk, params docs, AI gating flags)

**Remove split-brain client**

* `architect_frontend/src/services/api.ts`

  * Delete or convert to re-export of `architectApi`
  * Must not define its own base URL or endpoints

**Normalize base URL**

* `architect_frontend/src/lib/api.ts`

  * Must target `/api/v1` consistently (same-origin preferred in docker)

**Env + build-time configuration**

* `architect_frontend/.env.local`

  * Replace `NEXT_PUBLIC_API_URL` with `NEXT_PUBLIC_ARCHITECT_API_BASE_URL`
* `architect_frontend/next.config.mjs`

  * Keep only `NEXT_PUBLIC_ARCHITECT_API_BASE_URL`
  * Do not inject or rely on `NEXT_PUBLIC_API_URL`

### 4.3 Deployment

**Nginx**

* `deploy/nginx.conf`

  * Must proxy to docker service names (`frontend`, `backend`) not `127.0.0.1`
  * Must include an API route for `/abstract_wiki_architect/api/`

**Docker compose**

* `docker-compose.yml`

  * Frontend must set `NEXT_PUBLIC_ARCHITECT_API_BASE_URL`
  * Remove `NEXT_PUBLIC_API_URL`

---

## 5) Final API contract

### 5.1 Health

* `GET /api/v1/health`
  Response:

  ```json
  { "status": "ok" }
  ```

### 5.2 Languages (Public)

* `GET /api/v1/languages`
  Response:

  ```json
  [
    { "code": "eng", "name": "English", "z_id": "Z1002" },
    { "code": "zul", "name": "Zulu", "z_id": "Z1032" }
  ]
  ```

Notes:

* `z_id` may be nullable if not available.
* The public language `code` standard is an explicit product decision (ISO-639-3 if the UI depends on it). This update does not force a migration.
* Tool-facing language arguments (harvest/build scripts) use ISO-639-1 (ISO-2) codes (e.g., `en`, `fr`) and map via `iso_to_wiki.json`.

### 5.3 Languages (Admin)

* `POST /api/v1/languages` (onboard)
* `POST /api/v1/languages/{lang_code}/build` (trigger build)

Auth:

* Requires admin credentials (API key / token). No public access.

### 5.4 Entities

* `GET /api/v1/entities/` (list)
* `POST /api/v1/entities/` (create)
* `GET /api/v1/entities/{id}` (read)
* `PUT /api/v1/entities/{id}` (update)
* `DELETE /api/v1/entities/{id}` (delete)

Auth policy:

* Option A: public reads, protected writes
* Option B: all endpoints protected
* Option C: role-based

This update does not change entity schemas beyond wiring.

### 5.5 Tools (Admin)

#### 5.5.1 Registry

* `GET /api/v1/tools/registry`

Returns a list of tools with:

* `tool_id`, `description`
* `timeout_sec`
* `allow_args`
* `requires_ai_enabled`
* `available` (file exists on disk)

#### 5.5.2 Run tool

* `POST /api/v1/tools/run`
  Request:

  ```json
  {
    "tool_id": "language_health",
    "args": ["--mode", "compile", "--langs", "en", "fr"],
    "dry_run": false
  }
  ```

Response (stable envelope):

* `trace_id`, `success`, `command`
* `stdout`, `stderr` (+ back-compat `output`, `error`)
* `exit_code`, `duration_ms`
* `args_received`, `args_accepted`, `args_rejected`
* `truncation` info
* `events` (lifecycle telemetry)

Auth:

* Requires API key (router-level protection).

---

## 6) Implementation details (recommended patterns)

### 6.1 Backend router separation

Use two routers for languages:

* `languages.py` — public read endpoints (no auth)
* `languages_admin.py` or `management.py` — admin endpoints (auth enforced)

Avoid router-level `dependencies=[verify_api_key]` on mixed routers if any endpoints should be public.

### 6.2 Tools execution policy (required)

* Only run tools by allowlisted `tool_id` (no arbitrary paths).
* Validate args against per-tool allowed flags and value-shapes.
* Confine execution to `FILESYSTEM_REPO_PATH` repo root.
* Enforce output truncation and timeouts.
* Gate AI tools behind `ARCHITECT_ENABLE_AI_TOOLS`.

### 6.3 Uniform error envelope (recommended)

Standardize errors across backend:

```json
{
  "code": "AUTH_REQUIRED",
  "message": "API key required",
  "detail": { "reason": "missing_header" },
  "trace_id": "..."
}
```

---

## 7) Configuration (authoritative)

### 7.1 Local development (no nginx)

Frontend:

* `NEXT_PUBLIC_ARCHITECT_API_BASE_URL=http://localhost:8000/api/v1`

Backend:

* runs on `http://localhost:8000`

Tools router:

* `FILESYSTEM_REPO_PATH=/path/to/repo`
* optional:

  * `ARCHITECT_TOOLS_MAX_OUTPUT_CHARS=200000`
  * `ARCHITECT_TOOLS_DEFAULT_TIMEOUT_SEC=600`
  * `ARCHITECT_ENABLE_AI_TOOLS=0|1`

### 7.2 Docker compose (containers)

Recommended enterprise configuration:

* `NEXT_PUBLIC_ARCHITECT_API_BASE_URL=/abstract_wiki_architect/api/v1`

Then route via nginx:

* `/abstract_wiki_architect/api/` → backend
* `/abstract_wiki_architect/` → frontend

Tools router must still have:

* `FILESYSTEM_REPO_PATH` set correctly in the backend container.

### 7.3 Nginx routing (container-safe)

* UI: `/abstract_wiki_architect/` → `http://frontend:3000/`
* API: `/abstract_wiki_architect/api/` → `http://backend:8000/`

If backend mounts `/api/v1`, then:

* `/abstract_wiki_architect/api/v1/*` proxies to `http://backend:8000/api/v1/*`

---

## 8) Testing and validation

### 8.1 Contract tests (must-have)

Add automated tests that:

* assert `GET /api/v1/languages` returns objects with required fields
* assert `/api/v1/entities/` returns expected schema
* assert tools endpoints reject unauthenticated requests
* assert tools response envelope shape is stable (`trace_id`, `stdout`, `stderr`, `events`, `args_*`, `exit_code`)

### 8.2 CI checks (recommended)

* OpenAPI snapshot test
* Frontend build test: ensure no imports from deprecated client remain
* Lint rule: forbid `NEXT_PUBLIC_API_URL`
* Tool registry smoke: `GET /api/v1/tools/registry` returns at least the known IDs

### 8.3 Manual validation checklist

1. Load UI at `/abstract_wiki_architect`
2. Verify language dropdown loads and shows names/codes
3. Verify entities table loads
4. Verify tools page loads and lists registry tools (admin auth required)
5. Run a safe tool (e.g., `language_health --mode compile --langs en`) and confirm:

   * command shown
   * stdout/stderr captured
   * rejected args displayed if any
6. Verify AI-gated tools return 403 unless enabled

---

## 9) Rollback plan

Rollback is safe if you keep endpoints backward compatible temporarily.

### Recommended rollback mechanism

* Keep old endpoints as aliases for one release cycle:

  * If any legacy client calls `/languages` (without `/api/v1`), respond with 301 to `/api/v1/languages` or continue to serve it.
* Deploy with feature flags:

  * `PUBLIC_LANGUAGES_ENABLED=true/false`
  * `ENTITY_WRITE_AUTH_REQUIRED=true/false`
  * `TOOLS_ENABLED=true/false` (or simply unmount tools router)

Rollback steps:

1. revert nginx routing to previous known-good config
2. revert frontend to last version that matched old API base
3. keep backend router alias for `/languages` if needed
4. unmount tools router or disable it via config if required

---

## 10) Deliverables (what “done” looks like)

* One backend app entrypoint used everywhere (docker, prod, local)
* One frontend API client (no `services/api.ts` divergence)
* `GET /api/v1/languages` returns `Language[]` objects
* Nginx routes work in docker-compose using service names
* Env vars are unified on `NEXT_PUBLIC_ARCHITECT_API_BASE_URL`
* Security is explicit and not disabled in code paths
* Tools execution is allowlisted and admin-only (`/api/v1/tools/*`)
* Contract tests prevent regression
